#pragma once

#include <LazyEngine/LazyEngine.h>
#include "Halfedge.h"
#include "HalfedgeVectors.h"
#include "HalfedgeHashTables.h"
#include "../Utils/Intersections.h"
#include "../UniformGrid.h"

namespace DMC {

	// ##################################################################### //
	// ### HalfedgeMesh #################################################### //
	// ##################################################################### //

	class HalfedgeMesh {
	public:
		HalfedgeMesh();
		~HalfedgeMesh();

		/**
		 *	Initializes the halfedge-data structure
		 *	@param numQuads: The amount of quads stored in @param quads
		 *	@param numVertices: The amount of unique vertices
		 *	@param quads: The quads generated by DMC
		 */
		Performance initialize(size_t numQuads, size_t numVertices, QuadrilateralHostVector& quads);

		/**
		 *	To improve memory usage, the caller has control over when the hashtable must be available and when not.
		 */
		Performance initializeHashTable();
		/**
		 *	To improve memory usage, the caller can free the hashtable at any time if it is no longer needed.
		 */
		Performance freeHashTable();

		inline size_t getNumHalfedges() const {
			assert(m_halfedges != nullptr);
			return m_halfedges->size();
		}

		Performance simplify3X3Y(VertexHostVector& vertices, QuadrilateralHostVector& quads);

		Performance simplify3X3YOld(VertexHostVector& vertices, QuadrilateralHostVector& quads);

		Performance simplify3333(VertexHostVector& vertices, QuadrilateralHostVector& quads);

		/**
		 *	Refreshes the contents of the hash-table that is used to find non-manifold elements
		 */
		Performance refreshHashTable();

		/**
		 *	Returns the number of triangles
		 */
		uint32_t toVertexAndIndexBuffer(VertexHostVector& vertices, LazyEngine::DataView<Vertex>& vertexBuffer, LazyEngine::DataView<uint32_t>& indexBuffer);
		
		uint32_t toVertexAndIndexBuffer(VertexHostVector& vertices, Mesh& mesh);

		inline HalfedgeHostVector& getHalfedges() {
			assert(m_halfedges != nullptr);
			return *m_halfedges;
		}

		inline HalfedgeFaceHostVector& getHalfedgeFaces() {
			assert(m_halfedgeFaces != nullptr);
			return *m_halfedgeFaces;
		}

		inline HalfedgeVertexHostVector& getHalfedgeVertices() {
			assert(m_halfedgeVertices != nullptr);
			return *m_halfedgeVertices;
		}

		inline HalfedgeHostHashTable& getHashTable() {
			assert(m_hashTable != nullptr);
			return *m_hashTable;
		}

		/**
		 *	Returns the amount of edges that connect 4 faces
		 */
		int getNumNonManifoldEdges4();

		/**
		 *	Returns the amount of edges that connect 3 faces
		 */
		int getNumNonManifoldEdges3();
		
		int getNumEdges();

		int getNumQuadsWithNonManifoldEdges(int numNonManifoldEdges);

	protected:
		/**
		 *	Allocates Buffers for halfedges, halfedge-faces, halfedge-vertices and the halfedge-hash-table.
		 *	These Buffers will then be initialized with invalid data
		 */
		void initializeBuffers(Performance& performances, size_t numQuads, size_t numVertices);
		/**
		 *	Converts quads into Halfedges and Halfedge-Faces, that are not connected to any different faces yet.
		 */
		void collectHalfedges(Performance& performances, QuadrilateralHostVector& quads);
		/**
		 *	Connects Halfedges with their twins to create a complete mesh.
		 */
		void connectHalfedges(Performance& performances, QuadrilateralHostVector& quads);

	protected:
		std::unique_ptr<HalfedgeHostVector> m_halfedges;
		std::unique_ptr<HalfedgeFaceHostVector> m_halfedgeFaces;
		std::unique_ptr<HalfedgeVertexHostVector> m_halfedgeVertices;
		std::unique_ptr<HalfedgeHostHashTable> m_hashTable;
	};

}